import { createSlice, createAsyncThunk } from "@reduxjs/toolkit";
import { fetchTodo, insertTodo, updateTodo } from "./todoAPI";

const initialState = {
  value: [],
};

export const extractTodos = createAsyncThunk("todo/fetchTodo", async () => {
  const response = await fetchTodo();
  return response;
});

export const addTodo = createAsyncThunk("todo/insertTodo", async (data) => {
  const response = await insertTodo(data);
  return { ...data, _id: response.insertedId };
});

export const markComplete = createAsyncThunk("todo/updateTodo", async (id) => {
  await updateTodo(id);
  return id;
});

export const todoSlice = createSlice({
  name: "todo",
  initialState,
  // The `reducers` field lets us define reducers and generate associated actions
  reducers: {
    setDefaultState: async (state, action) => {
      state.value = action.payload;
    },
  },
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: (builder) => {
    builder
      .addCase(extractTodos.pending, (state) => {
        state.status = "loading";
      })
      .addCase(extractTodos.fulfilled, (state, action) => {
        state.status = "idle";
        state.value = action.payload;
      })
      .addCase(addTodo.pending, (state) => {
        state.status = "loading";
      })
      .addCase(addTodo.fulfilled, (state, action) => {
        state.status = "idle";
        state.value = [action.payload, ...state.value];
      })
      .addCase(markComplete.pending, (state) => {
        state.status = "loading";
      })
      .addCase(markComplete.fulfilled, (state, action) => {
        state.status = "idle";
        state.value = state.value.map((todo) =>
          todo._id === action.payload ? { ...todo, isComplete: 1 } : todo
        );
      });
  },
});

export const { setDefaultState } = todoSlice.actions;

export default todoSlice.reducer;
